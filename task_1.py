# 1. Проанализировать скорость и сложность одного любого алгоритма из разработанных в рамках домашнего задания первых
# трех уроков. Примечание. Идеальным решением будет:
# a. выбрать хорошую задачу, которую имеет смысл оценивать,
# b. написать 3 варианта кода (один у вас уже есть),
# c. проанализировать 3 варианта и выбрать оптимальный,
# d. результаты анализа вставить в виде комментариев в файл с кодом (не забудьте указать, для каких N вы проводили
# замеры),
# e. написать общий вывод: какой из трёх вариантов лучше и почему.

# Выбрана следующая задача:
# В одномерном массиве целых чисел определить два наименьших элемента.
# Они могут быть как равны между собой (оба минимальны), так и различаться.

import cProfile
from numpy.random import randint


def version_1(a):
    min_1 = 0
    for i, v in enumerate(a):
        if v < a[min_1]:
            min_1 = i

    min_2 = min_1 - 1
    for i, v in enumerate(a):
        if i != min_1 and v < a[min_2]:
            min_2 = i

    return a[min_1], a[min_2]


def version_2(a):
    size = len(a)

    if a[0] > a[1]:
        min_1 = 0
        min_2 = 1
    else:
        min_1 = 1
        min_2 = 0

    for i in range(2, size):
        if a[i] < a[min_1]:
            spam = min_1
            min_1 = i

            if a[spam] < a[min_2]:
                min_2 = spam

        elif a[i] < a[min_2]:
            min_2 = i

    return a[min_1], a[min_2]


def version_3(a):
    b = sorted(a)
    return b[0], b[1]


def test(size):
    a = randint(0, size, size)
    print(f'Алгоритм 1')
    print(f'Первое и второе минимальные числа: {version_1(a=a)}')
    print(f'Алгоритм 2')
    print(f'Первое и второе минимальные числа: {version_2(a=a)}')
    print(f'Алгоритм 3')
    print(f'Первое и второе минимальные числа: {version_3(a=a)}')


def main(size):
    a = randint(0, size, size)
    version_1(a=a)
    version_2(a=a)
    version_3(a=a)


#test(100000)
#test(1000000)
#test(10000000)
#test(100000000)


cProfile.run('main(100000)')
cProfile.run('main(1000000)')
cProfile.run('main(10000000)')
cProfile.run('main(100000000)')

# Результаты замеров.
#
#    ncalls  tottime  percall  cumtime  percall filename:lineno(function)
# SIZE = 100000
#         1    0.054    0.054    0.054    0.054 task_1.py:18(version_1)
#         1    0.047    0.047    0.047    0.047 task_1.py:32(version_2)
#         1    0.000    0.000    0.032    0.032 task_1.py:56(version_3)
# SIZE = 1000000
#         1    0.560    0.560    0.560    0.560 task_1.py:18(version_1)
#         1    0.462    0.462    0.462    0.462 task_1.py:32(version_2)
#         1    0.000    0.000    0.451    0.451 task_1.py:56(version_3)
# SIZE = 10000000
#         1    5.525    5.525    5.525    5.525 task_1.py:18(version_1)
#         1    4.628    4.628    4.628    4.628 task_1.py:32(version_2)
#         1    0.000    0.000    6.637    6.637 task_1.py:56(version_3)
# SIZE = 100000000
#         1   56.498   56.498   56.498   56.498 task_1.py:18(version_1)
#         1   47.357   47.357   47.357   47.357 task_1.py:32(version_2)
#         1    0.000    0.000   89.500   89.500 task_1.py:56(version_3)
#
# Из результатов видно что алгоритм 3 (самый простой по реализации) неплохо справляется на небольших объёмах.
# Но с увеличением числа элементов в выборке его скорость начинает падать и в лидеры выходит алгоритм 2 (основанный
# на одном проходе по выборке). Алгоритм 1 (основанный на двух проходах по выборке) стабильно отстаёт по скорости
# от алгоритма 2, что закономерно.
#
# Вывод: на небольших объёмах алгоритм 3 лучше - он слегка быстрее остальных и проще в реализации,
# на больших объёмах лучшим является алгоритм 2
